/*
 * Copyright 2017, International Business Machines
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


#include <string.h>
#include "ap_int.h"
#include "action_intersect_hls.h"

#define INTERSECT_ACTION_TYPE     0x0008

#define RELEASE_VERSION 0xFEEDA00800000010
//--------------------------------------------------------------------------------------------
// v1.0 : 03/24/2017 : creation 
//--------------------------------------------------------------------------------------------


// WRITE RESULTS IN MMIO REGS
void write_results_in_MC_regs(action_output_reg *Action_Output, action_input_reg *Action_Input, 
        ap_uint<32>result_num,
        ap_uint<32>ReturnCode)
{
    // To prevent duplication of Action_Output registers, always check that : 
    // - ALL Outputs are tied to a value and only one
    // - No read of Action_Output registers are done
    // If this is not followed, then Action_Output_i and Action_Output_o registers 
    // will be generated by HLS and address to read results will be shifted ...and wrong
    // => easy checking in generated files : grep 0x184 action_wrapper_ctrl_reg_s_axi.vhd
    // this grep should return nothing if no duplication of registers
    //
    ap_uint<8> i;
    Action_Output->Retc = (ap_uint<32>) ReturnCode;
    Action_Output->Reserved =  0; 

    Action_Output->Data.action_version       = RELEASE_VERSION; 
    Action_Output->Data.intsect_result       = Action_Input->Data.intsect_result;
    Action_Output->Data.intsect_result.size  = result_num;

    // Registers unchanged
    Action_Output->Data.src_table1        = Action_Input->Data.src_table1;
    Action_Output->Data.src_table2        = Action_Input->Data.src_table2;

    Action_Output->Data.step                 = Action_Input->Data.step;
    Action_Output->Data.rc                   = ReturnCode;
    Action_Output->Data.unused               = Action_Input->Data.unused;
}

short write_burst_of_data_to_mem(ap_uint<MEMDW> *dout_gmem, ap_uint<MEMDW> *d_ddrmem,
        ap_uint<16> memory_type, ap_uint<64> output_address,
        ap_uint<MEMDW> *buffer, ap_uint<64> size_in_bytes_to_transfer);
short read_burst_of_data_from_mem(ap_uint<MEMDW> *din_gmem, ap_uint<MEMDW> *d_ddrmem,
        ap_uint<16> memory_type, ap_uint<64> input_address,
        ap_uint<MEMDW> *buffer, ap_uint<64> size_in_bytes_to_transfer);
ap_uint<32> MIN32b(ap_uint<32> A, ap_uint<32> B);

//--------------------------------------------------------------------------------------------
//--- MAIN PROGRAM ---------------------------------------------------------------------------
//--------------------------------------------------------------------------------------------
void action_wrapper(ap_uint<MEMDW> *din_gmem, ap_uint<MEMDW> *dout_gmem, 
        ap_uint<MEMDW> *d_ddrmem,
        action_input_reg *Action_Input, action_output_reg *Action_Output)
{

    // Host Memory AXI Interface
#pragma HLS INTERFACE m_axi port=din_gmem bundle=host_mem
#pragma HLS INTERFACE m_axi port=dout_gmem bundle=host_mem
#pragma HLS INTERFACE s_axilite port=din_gmem bundle=ctrl_reg
#pragma HLS INTERFACE s_axilite port=dout_gmem bundle=ctrl_reg

    //DDR memory Interface
#pragma HLS INTERFACE m_axi port=d_ddrmem    bundle=card_mem0 offset=slave
#pragma HLS INTERFACE s_axilite port=d_ddrmem    bundle=ctrl_reg 

    // Host Memory AXI Lite Master Interface
#pragma HLS DATA_PACK variable=Action_Input
#pragma HLS INTERFACE s_axilite port=Action_Input offset=0x080 bundle=ctrl_reg
#pragma HLS DATA_PACK variable=Action_Output
#pragma HLS INTERFACE s_axilite port=Action_Output offset=0x104 bundle=ctrl_reg
#pragma HLS INTERFACE s_axilite port=return bundle=ctrl_reg


    // VARIABLES
    ap_uint<32> xfer_size;
    ap_uint<32> total_xfer_size;
    ap_uint<8> i;

    short rc = 0;

    ap_uint<32> ReturnCode;



    ap_uint<64> InputAddress;
    ap_uint<64> OutputAddress;
    ap_uint<64> address_xfer_offset;
    ap_uint<64> DDR_SRC_addr;
    ap_uint<64> DDR_RST_addr;

    ap_uint<MEMDW>   buf_gmem[MAX_NB_OF_BYTES_READ/BPERDW];   // if MEMDW=512 : 1024=>16 words
    ap_uint<MEMDW> buf_a_dram[MAX_NB_OF_BYTES_READ/BPERDW];   // if MEMDW=512 : 1024=>16 words
    ap_uint<MEMDW> buf_b_dram[MAX_NB_OF_BYTES_READ/BPERDW];   // if MEMDW=512 : 1024=>16 words

    ap_uint<MEMDW> local_bram[MAX_NB_OF_BYTES_READ/BPERDW];

    ap_uint<8*ENTRY_BYTES> node_a, node_b;
    
    ap_uint<MEMDW> local_res_buf[1];
    ap_uint<32> local_res_cnt;
    ap_uint<1> found;
    ap_uint<32> xfer_size_a, xfer_size_b;
    ap_uint<64> table_offset_a, table_offset_b;
    ap_uint<32> table_xfer_size;
    ap_uint<32> hhh, kkk, m;
    ap_uint<32> bytes_a, bytes_b;
    ap_uint<1> match_1, match_2;




    ReturnCode = RET_CODE_OK;

    if(Action_Input->Control.action == INTERSECT_ACTION_TYPE) 
    {

        if(Action_Input->Data.step == 1)
        {

            //calculate copy size and copy
            for(i = 0; i < NUM_TABLES; i++)
            {
                address_xfer_offset = 0x0;
                if(i == 0)
                {
                    table_xfer_size = Action_Input->Data.src_table1.size;
                    InputAddress = (Action_Input->Data.src_table1.address >> ADDR_RIGHT_SHIFT);
                    DDR_SRC_addr = 0;
                }
                else
                {
                    table_xfer_size = Action_Input->Data.src_table2.size;
                    InputAddress = (Action_Input->Data.src_table2.address >> ADDR_RIGHT_SHIFT);
                    DDR_SRC_addr = MAX_TABLE_SIZE >> ADDR_RIGHT_SHIFT; 
                    //Store tabel 2 to a different area.
                }


                //copy data from Host memory to DDR
L_COPY:         while(table_xfer_size > 0 and rc == 0)
                {
                    xfer_size = MIN32b(table_xfer_size, MAX_NB_OF_BYTES_READ);
                
                    if(DDR_SRC_addr +address_xfer_offset > CARD_DRAM_SIZE)
                    {
                        rc = 1;
                        break;
                    }


                    rc |= read_burst_of_data_from_mem(din_gmem, d_ddrmem, HOST_DRAM, 
                            InputAddress + address_xfer_offset, buf_gmem, xfer_size);

                    //Card address starts from zero.
                    rc |= write_burst_of_data_to_mem(dout_gmem, d_ddrmem, CARD_DRAM, 
                            DDR_SRC_addr + address_xfer_offset, buf_gmem, xfer_size);

                    table_xfer_size -= xfer_size;
                    address_xfer_offset += (ap_uint<64>)(xfer_size >> ADDR_RIGHT_SHIFT);
                } // end ofL_COPY


            }

        }
        else if (Action_Input->Data.step == 2)
        {
            rc = 0;
            local_res_cnt = 0;
            //Do intersection
                
            //Read a bulk from table a
            table_offset_a = 0;
            bytes_a        = Action_Input->Data.src_table1.size;

L1:         while (bytes_a > 0 and rc == 0)
            {

                xfer_size_a = MIN32b(bytes_a, MAX_NB_OF_BYTES_READ);
                rc |= read_burst_of_data_from_mem(din_gmem, d_ddrmem, CARD_DRAM, 
                        table_offset_a, buf_a_dram, xfer_size_a );

                table_offset_a += (ap_uint<64>)(xfer_size_a >> ADDR_RIGHT_SHIFT);
                bytes_a -= xfer_size_a;


                //Read a bulk from table b
                table_offset_b = 0;
                bytes_b = Action_Input->Data.src_table2.size;
L2:             while (bytes_b > 0 and rc == 0)
                {
                    xfer_size_b = MIN32b(bytes_b, MAX_NB_OF_BYTES_READ);
                    rc |= read_burst_of_data_from_mem(din_gmem, d_ddrmem, CARD_DRAM, 
                            (MAX_TABLE_SIZE >> ADDR_RIGHT_SHIFT) + table_offset_b, buf_b_dram, xfer_size_b );

                    table_offset_b += (ap_uint<64>)(xfer_size_b >> ADDR_RIGHT_SHIFT);
                    bytes_b -= xfer_size_b;


                    //Compare
                    //At most MAX_NB_OF_BYTES_READ/ENTRY_BYTES matches. 
                    //Save it in local BRAM
C1:                 for (hhh = 0; hhh < xfer_size_a/ENTRY_BYTES; hhh++)
                    {
                        node_a = buf_a_dram[hhh];

#pragma HLS UNROLL factor=4
C2:                     for (kkk =0; kkk < xfer_size_b/ENTRY_BYTES; kkk++)
                        {
                            //Here! BPERDW = 64, ENTRY_BYTES = 64
                            node_b = buf_b_dram[kkk];

                            match_1 = (node_a(255,0) == node_b(255,0));
                            match_2 = (node_a(511,256) == node_b(511, 256));
                            if(match_1 && match_2) //timing issue.
                            {
                                //Look up in result buffer
                                //Which is in DDR
                                found = 0;
C3:                             for( m = 0; m < local_res_cnt; m++)
                                {
                                    rc |= read_burst_of_data_from_mem(din_gmem, d_ddrmem, CARD_DRAM, 
                                            (RESULT_BUF_ADDR + m*ENTRY_BYTES)>> ADDR_RIGHT_SHIFT, local_res_buf, BPERDW );

                                    match_1 = (node_a(255,0) == local_res_buf[0](255,0));
                                    match_2 = (node_a(511,256) == local_res_buf[0](511,256));
                                    if(match_1 && match_2)
                                    {
                                        found = 1;
                                        break;
                                        //not insert
                                    }
                                }

                                //Need to insert a result.
                                if(found == 0)
                                {


                                    local_res_buf[0] = node_a;
                                    //Write to DDR. 
                                    DDR_RST_addr = (RESULT_BUF_ADDR + (local_res_cnt<<ENTRY_SHIFT)) >>ADDR_RIGHT_SHIFT;
                                    rc |= write_burst_of_data_to_mem(din_gmem, d_ddrmem, CARD_DRAM, 
                                            DDR_RST_addr, local_res_buf, BPERDW );

                                    local_res_cnt ++;
                                }
                            }
                        }
                    }
                }
            }
             //write back to host ram
            for (m = 0; m < local_res_cnt; m++)
            {

                rc |= read_burst_of_data_from_mem(din_gmem, d_ddrmem, CARD_DRAM, 
                        (RESULT_BUF_ADDR + m*ENTRY_BYTES)>> ADDR_RIGHT_SHIFT, local_res_buf, BPERDW );
                
                OutputAddress = (Action_Input->Data.intsect_result.address + m * ENTRY_BYTES)>> ADDR_RIGHT_SHIFT;
                rc |= write_burst_of_data_to_mem(din_gmem, d_ddrmem, HOST_DRAM, 
                        OutputAddress, local_res_buf, BPERDW );
            }

        }
        //else if (Action_Input ->Data.step == 3)
        //{
        //}
        if(rc!=0) ReturnCode = RET_CODE_FAILURE;

    }
    else  // unknown action
        ReturnCode = RET_CODE_FAILURE;

    write_results_in_MC_regs(Action_Output, Action_Input, local_res_cnt*ENTRY_BYTES, ReturnCode); 

    return;
}


